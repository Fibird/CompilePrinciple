/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(Parser)package grammar;

public class Parser{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");    new Parser(System.in);    try    {      SimpleNode n = Parser.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(Parser)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])?     >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >}
TOKEN : /* KEYS */
{
  < INT : "int" >
| < DOUBLE : "double" >
| < FLOAT : "float" >
| < CHAR : "char" >
| < VOID : "void" >
| < FOR : "for" >
| < WHILE : "while" >
| < RETURN : "return" >
| < IF : "if" >
| < MAIN : "main" >
}
TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}

TOKEN : /* OPERATORS */
{
 < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < ASSIGN : "=" >
}

TOKEN : /* RELATIONS */
{
  < RELATIONS : <GT> | <LT> | <EQUAL> | <LOWEQU> | <GREATEQU> | <NEQUAL>> | < #GT : ">" >
| < #LT : "<" >
| < #EQUAL : "==" >
| < #NEQUAL : "!=" >
| < #LOWEQU : "<=" >
| < #GREATEQU : ">=" >
}
TOKEN : /* SEPARATER */
{
  < QUATION : "\"" >
| < SEMICOLON : ";" >
| < LCURLY_BRACE : "{" >
| < RCURLY_BRACE : "}" >
| < LBRACE : "(" >
| < RBRACE : ")" >
| < COMMA : "," >
| < EXCLA_SYM : "!" >
}SimpleNode Start() :{}{  Program()  {    return jjtThis;  }}

void Program() :
{}
{	<INT>
	< MAIN >
	< LBRACE >
	< RBRACE>
	< LCURLY_BRACE>
	(SentenceBlock())*
	< RCURLY_BRACE>
}

void SentenceBlock() :
{}
{	Sentence()
	| < LCURLY_BRACE>
	( SentenceBlock() )*
	< RCURLY_BRACE>
}
void Sentence() :
{}
{
  SequenceSent()
  | ConditionSent()
  | LoopSent()}

void SequenceSent() :
{}
{
  //DeclareSent() // just for test
  [ DeclareSent()
  | AssigmentSent() ]
  < SEMICOLON>}
void ConditionSent() :
{}
{
  <IF>
   Condition()
   SentenceBlock()
}

void LoopSent() :
{}
{
  <WHILE>
  Condition()
   SentenceBlock()
}

void DeclareSent() :
{}
{
  	[
  	<INT>
   |<DOUBLE>
   | <FLOAT>
   | <CHAR>
   ]
   /*(
     LOOKAHEAD(Identifier())
     <COMMA>
   )**/
   Identifier()
   < SEMICOLON>
}

void AssigmentSent() :
{}
{
  Identifier()
  <ASSIGN>
  Expression()
  <SEMICOLON>
}

void Condition() :
{}
{
  "("
  Expression()
  <RELATIONS>
  Expression()
  ")"}

void Expression_c() :
{ }
{
  (
    "+"
  | "-"
  Expression()
  Expression()  )
}
  
void Expression() :{}{  AdditiveExpression()}void AdditiveExpression() :{}{  MultiplicativeExpression()  (    (      "+"    | "-"    )    MultiplicativeExpression()  )*}void MultiplicativeExpression() :{}{  UnaryExpression()  (    (      "*"    | "/"    | "%"    )    UnaryExpression()  )*}void UnaryExpression() :{}{  "(" Expression() ")"| Identifier()| Integer()}void Identifier() :{}{  < IDENTIFIER >}void Integer() :{}{  < INTEGER_LITERAL >}
